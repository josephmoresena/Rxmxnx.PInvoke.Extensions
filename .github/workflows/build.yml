name: Build
on:
  push:
    branches:
      - main
  pull_request:
    types: [ opened, synchronize, reopened ]
jobs:
  build:
    name: Build and analyze
    runs-on: ubuntu-latest
    steps:
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: 21
          distribution: 'zulu'
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 9.x
      - name: Setup Tree pre-requisites
        run: sudo apt-get install tree unzip --assume-yes
      - name: Setup latest Mono Framework
        run: |
          sudo apt install ca-certificates gnupg --assume-yes
          sudo gpg --homedir /tmp --no-default-keyring --keyring /usr/share/keyrings/mono-official-archive-keyring.gpg --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 3FA7E0328081BFF6A14DA29AA6A19B38D3D831EF
          echo "deb [signed-by=/usr/share/keyrings/mono-official-archive-keyring.gpg] https://download.mono-project.com/repo/ubuntu stable-focal main" | sudo tee /etc/apt/sources.list.d/mono-official-stable.list
          sudo apt update
          sudo apt install mono-complete
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Shallow clones should be disabled for a better relevancy of analysis
      - name: Cache SonarCloud packages
        uses: actions/cache@v4
        with:
          path: ~/sonar/cache
          key: ${{ runner.os }}-sonar
          restore-keys: ${{ runner.os }}-sonar
      - name: Cache SonarCloud scanner
        id: cache-sonar-scanner
        uses: actions/cache@v4
        with:
          path: ./.sonar/scanner
          key: ${{ runner.os }}-sonar-scanner
          restore-keys: ${{ runner.os }}-sonar-scanner
      - name: Install SonarCloud scanner
        if: steps.cache-sonar-scanner.outputs.cache-hit != 'true'
        shell: pwsh
        run: |
          New-Item -Path ./.sonar/scanner -ItemType Directory
          dotnet tool update dotnet-sonarscanner --tool-path ./.sonar/scanner 
      - name: Build and analyze Sonar
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # Needed to get PR information, if any
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        shell: pwsh
        run: |
          ./.sonar/scanner/dotnet-sonarscanner begin /k:"josephmoresena_PInvoke.Extensions" /o:"josephmoresena" /d:sonar.token="${{ secrets.SONAR_TOKEN }}" /d:sonar.host.url="https://sonarcloud.io" /d:sonar.scanner.scanAll=false /d:sonar.coverage.exclusions="**Test.cs,**Tests.cs,**test.cs,**tests.cs,**.SourceGenerator/*.cs" /d:sonar.cs.vstest.reportsPaths=TestResults/*.trx /d:sonar.cs.opencover.reportsPaths=TestResults/*/coverage.opencover.xml /d:sonar.cpd.exclusions="**/NativeUtilities/**FixedAction.cs,**/NativeUtilities/**FixedFunc.cs,**/IManagedBinaryBuffer/StaticCompose.cs,**Test/**Tests**/**.cs,**/Localization/**MessageResource.cs"
          dotnet restore src 
          dotnet build src --configuration release 
          dotnet test src --verbosity normal --collect:"XPlat Code Coverage" --results-directory TestResults/  --logger "trx;verbosity=detailed" --no-build --no-restore --configuration release -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Format=opencover 
          ./.sonar/scanner/dotnet-sonarscanner end /d:sonar.token="${{ secrets.SONAR_TOKEN }}"
      - name: Pack assembly
        working-directory: ./package/Rxmxnx.PInvoke.Extensions
        run: |
          dotnet pack -c Release /p:Version=9999.99.99.99-tmp /p:NoIntermediateBuild=true
          for package in bin/Release/Rxmxnx.PInvoke.Extensions*.*nupkg; do
            echo "-----------------------------------"
            TEMP_DIR=$(mktemp -d)
            unzip -q "$package" -d "$TEMP_DIR"
            ls -sh "$package"
            tree "$TEMP_DIR" -h --noreport | tail -n +2 | sed "s|$TEMP_DIR/||"
            rm -rf "$TEMP_DIR"
          done
          echo "-----------------------------------"
      - name: Create tmpProject
        run: mkdir tmpProject
      - name: Create PackageTrimmedAssembly.csproj
        working-directory: ./tmpProject
        run: |
          echo '<Project>' > Directory.Build.props
          echo '  <ItemGroup>' >> Directory.Build.props
          echo '    <RuntimeHostConfigurationOption Condition="'"'"'$(DisableBufferAutoComposition)'"'"' == '"'"'true'"'"'" Include="PInvoke.DisableBufferAutoComposition" Value="true" Trim="true" />' >> Directory.Build.props
          echo '  </ItemGroup>' >> Directory.Build.props
          echo '</Project>' >> Directory.Build.props  
          dotnet new console --name PackageTrimmedAssembly --aot true
      - name: Create PackageTrimmedAssembly NuGet.config
        working-directory: ./tmpProject/PackageTrimmedAssembly
        run: |
          dotnet new nugetconfig
          dotnet nuget add source ../../package/Rxmxnx.PInvoke.Extensions/bin/Release/ -n TmpSource
          dotnet add package Rxmxnx.PInvoke.Extensions --version 9999.99.99.99-tmp
      - name: Create PackageTrimmedAssembly Program.cs
        working-directory: ./tmpProject/PackageTrimmedAssembly
        run: |
          echo '#if !NETCOREAPP
          using System;
          using System.Linq;
          using System.Runtime.CompilerServices;
          #else
          using System.Text.Json;
          #endif
          using System.Reflection;
          using System.Buffers;
          using System.Globalization;
          using System.Runtime.InteropServices;
          using System.Text;
          
          namespace Rxmxnx.PInvoke.ApplicationTest
          {
          	internal static class Program
          	{
          		public static void Main()
          		{
          			RuntimeHelper.PrintRuntimeInfo();
          
          			Double[,] mxm = { { 0.3, -2.2, 3.2, 0, }, { 0.12, -2, 0.2, 6, }, { 9, 0, 0, -1, }, { 2, 2.1, -1, 4, }, };
          			Double[,] nxn = { { 2, 3, }, { 2, 1, }, };
          			Double[,] mxn = { { -1, 1, }, { 4, 0, }, { 2, 1, }, { 1, 3, }, };
          
          			Console.WriteLine("=== 4x4 ===");
          			Program.Print(mxm);
          			Console.WriteLine($"Determinant 4x4: {Program.GetDeterminant(mxm, out Double[,] inverse):0.####}");
          			Console.WriteLine("=== (4x4)^-1 ===");
          			Program.Print(inverse);
          			Console.WriteLine("=== 2x2 ===");
          			Program.Print(nxn);
          			Console.WriteLine($"Determinant 2x2: {Program.GetDeterminant(nxn):0.####}");
          			Console.WriteLine("=== 4x2 ===");
          			Program.Print(mxn);
          			Console.WriteLine("=== 4x4 * 4x2 ===");
          			Program.Print(Program.Multiply(mxm, mxn));
          			Console.WriteLine("=== 2x2 -> [] ===");
          			mxn.AsSpan().WithSafeFixed(Program.Print);
          			Console.WriteLine("=== Stack alloc String ===");
          			BufferManager.Alloc<String?>(13, Program.Generate);
          
          #if NETCOREAPP
          			Console.WriteLine("=== System.Text.Json ===");
          #else
          			Console.WriteLine("=== UTF-8 / UTF-16 Convert ===");
          #endif
          			SerializableMessage<String> serializable = ConvertHelper.Convert(new SerializableMessage<CString>
          			{
          				Title =
          					(CString)
          					"This is not a message",
          				Message =
          					(CString)
          					"This is a UTF-8 message for you.",
          			});
          			Console.WriteLine(ConvertHelper.Convert(serializable));
          			CStringSequence result = ConvertHelper.Convert(
          				ConvertHelper.Convert(new CStringSequence("String0", "String1", null, "String3", "", "String5")));
          			Console.WriteLine("=== Enumerable sequences ===");
          			foreach (CString value in result)
          				Console.WriteLine(!value.IsZero ? value : RuntimeHelper.Null);
          			foreach (Byte utf8U in RuntimeHelper.Null)
          				Console.Write((Char)utf8U);
          			ArrayWrapper<Int32> values = new ArrayWrapper<Int32> { Value = new Int32[] { 1, 2, 3, -1, -2, -3, }, };
          			foreach (Int32 val in values)
          				Console.WriteLine(val);
          			Console.WriteLine("=== UTF-8 Enumerable ===");
          			foreach (ReadOnlySpan<Byte> utf8 in result.CreateView())
          				Console.WriteLine($"Address: 0x{utf8.GetUnsafeIntPtr().ToString("X")}\t" +
          				                  $"Length: {utf8.Length}\tBytes: {Convert.ToBase64String(utf8)}\t" +
          				                  $"Text:{Encoding.UTF8.GetString(utf8)}.");
          			Console.WriteLine("=== Referenceable Wrapper ===");
          			IMutableReference<Guid> uuid = IMutableReference.Create(Guid.NewGuid());
          
          			Program.Print(uuid);
          			uuid.Reference = Guid.NewGuid();
          			Program.Print(uuid);
          
          			Console.WriteLine("=== Fixed Rent ===");
          			using IFixedContext<Int64>.IDisposable fRent =
          				ArrayPool<Int64>.Shared.RentFixed(10, false, out Int32 arrayLength);
          			Console.WriteLine(
          				$"Address: 0x{fRent.Pointer.ToString("X")} Required: {fRent.Values.Length} Rented: {arrayLength}");
          			foreach (ref Int64 rLong in fRent.Values)
          				rLong = RuntimeHelper.Shared.Next();
          			Program.Print(fRent);
          		}
          
          		private static Double GetDeterminant(Double[,] matrix)
          		{
          			Int32 n;
          			if (matrix.Rank != 2 || (n = matrix.GetLength(0)) != matrix.GetLength(1))
          				throw new InvalidOperationException("Determinant is only for square matrices.");
          			if (n == 0)
          				return 1;
          
          			Double determinant = MatrixHelper.GetDeterminant(matrix.AsSpan(), n);
          			return determinant;
          		}
          		private static Double GetDeterminant(Double[,] matrix, out Double[,] inverse)
          		{
          			Int32 n;
          			if (matrix.Rank != 2 || (n = matrix.GetLength(0)) != matrix.GetLength(1))
          				throw new InvalidOperationException("Determinant is only for square matrices.");
          			if (n == 0)
          			{
          				inverse = MatrixHelper.EmptyMatrix;
          				return 1;
          			}
          
          			Double determinant = MatrixHelper.GetDeterminant(matrix.AsSpan(), n, out inverse);
          			return determinant;
          		}
          		private static Double[,] Multiply(Double[,] matrixA, Double[,] matrixB)
          		{
          			if (matrixA.Rank != 2)
          				throw new InvalidOperationException("Invalid A matrix.");
          			if (matrixB.Rank != 2)
          				throw new InvalidOperationException("Invalid B matrix.");
          
          			Int32 aRow = matrixA.GetLength(0);
          			Int32 bCol = matrixB.GetLength(1);
          			Int32 n;
          			if ((n = matrixA.GetLength(1)) != matrixB.GetLength(0))
          				throw new InvalidOperationException(
          					"The number of columns in A matrix must equal the number of rows in B matrix.");
          
          			if (aRow == 0 || n == 0 || bCol == 0) return MatrixHelper.EmptyMatrix;
          			Double[,] result = new Double[aRow, bCol];
          
          			MatrixHelper.MultiplyMatrices(matrixA.AsSpan(), matrixB.AsSpan(), aRow, bCol, n, result.AsSpan());
          			return result;
          		}
          		private static void Generate(ScopedBuffer<String?> buff)
          		{
          			Console.WriteLine($"Span Size: {buff.Span.Length}");
          			Console.WriteLine($"Buffer Size: {buff.FullLength}");
          			Console.WriteLine($"In Stack: {buff.InStack}");
          			Console.WriteLine(
          				$"Components: {String.Join(", ", buff.BufferMetadata?.Select(c => c.Size) ?? Enumerable.Empty<UInt16>())}");
          
          			for (Int32 i = 0; i < buff.Span.Length; i++)
          				buff.Span[i] = $"Index: {i} Value: {Guid.NewGuid()}";
          
          			Program.Print(buff.Span);
          			Program.CollectGarbage();
          			Program.Print(buff.Span);
          		}
          		private static void CollectGarbage()
          		{
          			Console.WriteLine("Begin GC.Collect()");
          			GC.Collect();
          			try
          			{
          				GC.WaitForFullGCComplete();
          			}
          			catch (NotImplementedException)
          			{
          				Console.WriteLine("**Unable to call GC.WaitForFullGCComplete()**");
          			}
          			Console.WriteLine("End GC.Collect()");
          		}
          		private static void Print(Double[,] matrix)
          		{
          			if (matrix.Rank != 2)
          				throw new InvalidOperationException("Invalid matrix.");
          			if (matrix.GetLength(0) <= 0 || matrix.GetLength(0) <= 0) return;
          			MatrixHelper.PrintMatrix(matrix.AsSpan(), matrix.GetLength(0), matrix.GetLength(1));
          		}
          		private static void Print(ReadOnlySpan<String?> span)
          		{
          			foreach (ref readonly String? str in span)
          				Console.WriteLine(str);
          		}
          		private static void Print(IMutableReference<Guid> uuid)
          		{
          			Program.CollectGarbage();
          			ref Guid refU = ref uuid.Reference;
          			Console.WriteLine(
          				$"Address: 0x{refU.AsBytes().GetUnsafeIntPtr().ToString("X")} Wrapper: {uuid.Value} Ref: {uuid.Reference}");
          		}
          		private static void Print<T>(in IFixedContext<T> ctx)
          		{
          			Console.Write($"Address: 0x{ctx.Pointer.ToString("X")} Items: " + ctx.Values.Length);
          			foreach (T value in ctx.Values)
          				Console.Write($"{value} ");
          			Console.WriteLine("");
          		}
          
          		private static String GetName(this Architecture architecture)
          			=> architecture switch
          			{
          				Architecture.X86 => nameof(Architecture.X86),
          				Architecture.X64 => nameof(Architecture.X64),
          				Architecture.Arm => nameof(Architecture.Arm),
          				Architecture.Arm64 => nameof(Architecture.Arm64),
          #if NET5_0_OR_GREATER
          				Architecture.Wasm => nameof(Architecture.Wasm),
          #endif
          #if NET6_0_OR_GREATER
          				Architecture.S390x => nameof(Architecture.S390x),
          #endif
          #if NET7_0_OR_GREATER
          				Architecture.LoongArch64 => nameof(Architecture.LoongArch64),
          				Architecture.Armv6 => nameof(Architecture.Armv6),
          				Architecture.Ppc64le => nameof(Architecture.Ppc64le),
          #endif
          #if NET9_0_OR_GREATER
          				Architecture.RiscV64 => nameof(Architecture.RiscV64),
          #endif
          				_ => architecture.ToString(),
          			};
          
          		private class SerializableMessage<T>
          			where T : class, IEquatable<String>, IEquatable<T>, IComparable<String>, IComparable<T>
          		{
          			public T? Title { get; set; }
          			public T? Message { get; set; }
          
          			public override String ToString()
          				=> $"{{ Title: {this.Title?.ToString() ?? "null"}, Message: {this.Message?.ToString() ?? ""} }}";
          		}
          
          		private static class ConvertHelper
          		{
          			public static SerializableMessage<String> Convert(SerializableMessage<CString> value)
          #if !NETCOREAPP
          			=> new SerializableMessage<String>
          			{
          				Title = value.Title?.ToString(), Message = value.Message?.ToString(),
          			};
          #else
          			{
          				String serialized = JsonSerializer.Serialize(value);
          				return JsonSerializer.Deserialize<SerializableMessage<String>>(serialized)!;
          			}
          #endif
          			public static SerializableMessage<CString> Convert(SerializableMessage<String> value)
          #if !NETCOREAPP
          			=> new SerializableMessage<CString> { Title = (CString?)value.Title, Message = (CString?)value.Message, };
          #else
          			{
          				String serialized = JsonSerializer.Serialize(value);
          				return JsonSerializer.Deserialize<SerializableMessage<CString>>(serialized)!;
          			}
          #endif
          			public static String?[] Convert(CStringSequence sequence)
          			{
          #if NETCOREAPP
          				String serialized = JsonSerializer.Serialize(sequence);
          				return JsonSerializer.Deserialize<String?[]>(serialized)!;
          #else
          			String?[] result = new String?[sequence.Count];
          			Int32 index = 0;
          			foreach (ReadOnlySpan<Byte> utf8Text in sequence.CreateView())
          			{
          				result[index] = !Unsafe.IsNullRef(ref MemoryMarshal.GetReference(utf8Text)) ?
          					Encoding.UTF8.GetString(utf8Text) :
          					default;
          				index++;
          			}
          			return result;
          #endif
          			}
          			public static CStringSequence Convert(params String?[] sequence)
          #if !NETCOREAPP
          			=> new CStringSequence(sequence);
          #else
          			{
          				String serialized = JsonSerializer.Serialize(sequence);
          				return JsonSerializer.Deserialize<CStringSequence>(serialized)!;
          			}
          #endif
          		}
          
          		private class ArrayWrapper<T> : IEnumerableSequence<T>, IMutableWrapper<T[]>
          		{
          			public T[] Value { get; set; } = Array.Empty<T>();
          
          			public Int32 GetSize() => this.Value.Length;
          			public T GetItem(Int32 index) => this.Value[index];
          		}
          
          		private static class MatrixHelper
          		{
          			private const Double epsilon = 1e-12;
          
          			public static readonly Double[,] EmptyMatrix = new Double[0, 0];
          
          			public static Double GetDeterminant(ReadOnlySpan<Double> matrix, Int32 n)
          			{
          				Double[]? array = default;
          				Span<Double> tempMatrix = n > 4 ?
          					(array = ArrayPool<Double>.Shared.Rent(matrix.Length)).AsSpan()[..matrix.Length] :
          					stackalloc Double[matrix.Length];
          				try
          				{
          					matrix.CopyTo(tempMatrix);
          
          					Double det = 1;
          					Int32 swaps = 0;
          
          					for (Int32 row = 0; row < n; row++)
          					{
          						Double pivot = MatrixHelper.GetPivot(tempMatrix, n, false, row, out Int32 maxRow);
          
          						if (Math.Abs(pivot) < MatrixHelper.epsilon)
          							return 0;
          
          						swaps += MatrixHelper.SwapRow(tempMatrix, n, row, maxRow) ? 1 : 0;
          
          						for (Int32 k = row + 1; k < n; k++)
          						{
          							Double factor = tempMatrix[k * n + row] / tempMatrix[row * n + row];
          							for (Int32 j = row; j < n; j++)
          								tempMatrix[k * n + j] -= factor * tempMatrix[row * n + j];
          						}
          					}
          
          					for (Int32 i = 0; i < n; i++)
          						det *= tempMatrix[i * n + i];
          					if (swaps % 2 != 0) det = -det;
          					return det;
          				}
          				finally
          				{
          					if (array is not null)
          						ArrayPool<Double>.Shared.Return(array);
          				}
          			}
          			public static Double GetDeterminant(ReadOnlySpan<Double> matrix, Int32 n, out Double[,] inverse)
          			{
          				Double[]? array = default;
          				Span<Double> augmented = n > 4 ?
          					(array = ArrayPool<Double>.Shared.Rent(2 * matrix.Length)).AsSpan()[..(2 * matrix.Length)] :
          					stackalloc Double[2 * matrix.Length];
          				try
          				{
          					Double determinant = 1.0;
          					Int32 swaps = 0;
          
          					MatrixHelper.FillAugmented(matrix, n, augmented);
          					for (Int32 row = 0; row < n; row++)
          					{
          						Double pivot = MatrixHelper.GetPivot(augmented, n, true, row, out Int32 maxRow);
          						if (Math.Abs(pivot) < MatrixHelper.epsilon)
          						{
          							inverse = MatrixHelper.EmptyMatrix;
          							return 0;
          						}
          
          						determinant *= pivot;
          						swaps += MatrixHelper.SwapRow(augmented, 2 * n, row, maxRow) ? 1 : 0;
          						MatrixHelper.NormalizeRow(augmented, n, row, pivot);
          						MatrixHelper.RowReduction(augmented, n, row);
          					}
          
          					inverse = new Double[n, n];
          					if (swaps % 2 != 0)
          						determinant = -determinant;
          					MatrixHelper.CopyInverse(augmented, n, inverse.AsSpan());
          					return determinant;
          				}
          				finally
          				{
          					if (array is not null)
          						ArrayPool<Double>.Shared.Return(array);
          				}
          			}
          			public static void MultiplyMatrices(ReadOnlySpan<Double> matrixA, ReadOnlySpan<Double> matrixB, Int32 aRow,
          				Int32 bCol, Int32 n, Span<Double> result)
          			{
          				for (Int32 row = 0; row < aRow; row++)
          				for (Int32 aCol = 0; aCol < bCol; aCol++)
          				{
          					Double sum = 0;
          					for (Int32 col = 0; col < n; col++)
          						sum += matrixA[row * n + col] * matrixB[col * bCol + aCol];
          					result[row * bCol + aCol] = sum;
          				}
          			}
          
          			private static void FillAugmented(ReadOnlySpan<Double> matrix, Int32 n, Span<Double> augmented)
          			{
          				// [A | I]
          				for (Int32 row = 0; row < n; row++)
          				for (Int32 col = 0; col < n; col++)
          					(augmented[row * 2 * n + col], augmented[row * 2 * n + col + n]) =
          						(matrix[row * n + col], row == col ? 1.0 : 0.0);
          			}
          			private static void CopyInverse(Span<Double> augmented, Int32 n, Span<Double> inverseAsSpan)
          			{
          				for (Int32 i = 0; i < n; i++)
          				for (Int32 j = 0; j < n; j++)
          					inverseAsSpan[i * n + j] = augmented[i * 2 * n + j + n];
          			}
          			private static void NormalizeRow(Span<Double> augmented, Int32 n, Int32 row, Double pivot)
          			{
          				for (Int32 col = 0; col < 2 * n; col++)
          					augmented[row * 2 * n + col] /= pivot;
          			}
          			private static void RowReduction(Span<Double> augmented, Int32 n, Int32 normalizedRow)
          			{
          				for (Int32 row = 0; row < n; row++)
          				{
          					if (row == normalizedRow) continue;
          					Double factor = augmented[row * 2 * n + normalizedRow];
          					for (Int32 col = 0; col < 2 * n; col++)
          						augmented[row * 2 * n + col] -= factor * augmented[normalizedRow * 2 * n + col];
          				}
          			}
          			private static Double GetPivot(ReadOnlySpan<Double> matrix, Int32 n, Boolean isAugmented, Int32 currentRow,
          				out Int32 maxRow)
          			{
          				maxRow = currentRow;
          
          				Int32 multiplier = isAugmented ? 2 : 1;
          				for (Int32 row = currentRow + 1; row < n; row++)
          					if (Math.Abs(matrix[row * multiplier * n + currentRow]) >
          					    Math.Abs(matrix[maxRow * multiplier * n + currentRow]))
          						maxRow = row;
          				return matrix[maxRow * multiplier * n + currentRow];
          			}
          			public static void PrintMatrix(ReadOnlySpan<Double> matrix, Int32 nRow, Int32 nCol)
          			{
          				Int32 addCol = (matrix.Length - nRow * nCol) / nRow;
          				StringBuilder? strBuild = addCol > 0 ? new StringBuilder() : default;
          				for (Int32 row = 0; row < nRow; row++)
          				{
          					strBuild?.Append("\t|\t");
          					for (Int32 col = 0; col < nCol; col++)
          					{
          						Console.Write($"{matrix[row * (nCol + addCol) + col]:0.####}\t");
          						if (strBuild is null || col >= addCol) continue;
          						strBuild.Append($"{matrix[row * (nCol + addCol) + col + nRow]:0.####}\t");
          					}
          					Console.WriteLine(strBuild?.ToString());
          					strBuild?.Clear();
          				}
          			}
          			private static Boolean SwapRow(Span<Double> matrix, Int32 nCol, Int32 row1, Int32 row2)
          			{
          				if (row1 == row2) return false;
          				for (Int32 col = 0; col < nCol; col++)
          					(matrix[row1 * nCol + col], matrix[row2 * nCol + col]) = (matrix[row2 * nCol + col],
          						matrix[row1 * nCol + col]);
          				return true;
          			}
          		}
          
          		private static class RuntimeHelper
          		{
          			private const String literalName =
          #if !NETCOREAPP
          				"Read-only byte span"
          #else
          					"UTF-8 literal"
          #endif
          				;
          			private static ReadOnlySpan<Byte> GetLiteralNull()
          #if !NETCOREAPP
          		=> (new Byte[] { 110, 117, 108, 108, 0, }).AsSpan()[..^1];
          #else
          				=> "null"u8;
          #endif
          
          			public static readonly CString Null = new(RuntimeHelper.GetLiteralNull);
          			public static readonly Random Shared = new Random();
          
          			public static void PrintRuntimeInfo()
          			{
          				const String runtimeName =
          #if NET9_0_OR_GREATER
          					".NET 9.0"
          #elif NET8_0_OR_GREATER
          					".NET 8.0"
          #elif NET7_0_OR_GREATER
          					".NET 7.0"
          #elif NET6_0_OR_GREATER
          					".NET 6.0"
          #elif NET5_0_OR_GREATER
          					".NET 5.0"
          #elif NETCOREAPP3_1
          					".NET Core 3.1"
          #elif NETCOREAPP3_0
          						".NET Core 3.0"
          #else
          					"Mono"
          #endif
          #if REFLECTION_FREE
          					+ " Reflection-free"
          #endif
          #if NATIVE_AOT
          					+ " NativeAOT"
          #endif
          					;
          				Console.WriteLine("========== Application for " + runtimeName + " ==========");
          				RuntimeHelper.PrintDomainInfo();
          				Console.WriteLine("========== Runtime information ==========");
          				Console.WriteLine($"Number of Cores: {Environment.ProcessorCount}");
          				Console.WriteLine($"Is Little-Endian: {BitConverter.IsLittleEndian}");
          				Console.WriteLine($"OS: {RuntimeInformation.OSDescription}");
          				Console.WriteLine($"OS Arch: {RuntimeInformation.OSArchitecture.GetName()}");
          				Console.WriteLine($"OS Version: {Environment.OSVersion}");
          				Console.WriteLine($"Computer: {Environment.MachineName}");
          				Console.WriteLine($"User: {Environment.UserName}");
          				Console.WriteLine($"UI Culture: {CultureInfo.CurrentUICulture.TwoLetterISOLanguageName}");
          				Console.WriteLine($"System Path: {Environment.SystemDirectory}");
          				Console.WriteLine($"Current Path: {Environment.CurrentDirectory}");
          				Console.WriteLine($"Process Arch: {RuntimeInformation.ProcessArchitecture.GetName()}");
          				try
          				{
          					Console.WriteLine($"Framework Version: {Environment.Version}");
          					Console.WriteLine($"Runtime Path: {RuntimeEnvironment.GetRuntimeDirectory()}");
          					Console.WriteLine($"Runtime Version: {RuntimeEnvironment.GetSystemVersion()}");
          				}
          				catch (Exception)
          				{
          					Console.WriteLine("**Unable to retrieve runtime info**");
          				}
          				Console.WriteLine("========== Rxmxnx.PInvoke Runtime information ==========");
          				Console.WriteLine($"Native AOT: {AotInfo.IsNativeAot}");
          				Console.WriteLine($"Reflection Enabled: {!AotInfo.IsReflectionDisabled}");
          				Console.WriteLine($"Pointer Size: {NativeUtilities.PointerSize}");
          				Console.WriteLine($"Globalization-Invariant Mode: {NativeUtilities.GlobalizationInvariantModeEnabled}");
          				Console.WriteLine($"UI Iso639-1: {NativeUtilities.UserInterfaceIso639P1}");
          				Console.WriteLine($"Buffer AutoComposition Enabled: {BufferManager.BufferAutoCompositionEnabled}");
          				Console.WriteLine($"{RuntimeHelper.literalName}: {RuntimeHelper.GetLiteralNull().IsLiteral()}");
          				Console.WriteLine($"String constant: {RuntimeHelper.literalName.AsSpan().IsLiteral()}");
          			}
          			private static void PrintDomainInfo()
          			{
          				try
          				{
          					ReadOnlySpan<Assembly> span = AppDomain.CurrentDomain.GetAssemblies();
          					foreach (Assembly assembly in span)
          						Console.WriteLine(assembly.FullName + " " + assembly.Location);
          				}
          				catch (Exception)
          				{
          					Console.WriteLine("**Unable to retrieve domain info**");
          				}
          			}
          		}
          	}
          }' > Program.cs
      - name: Build Package-Trimmed-Executables (PackageTrimmedAssembly)
        working-directory: ./tmpProject/PackageTrimmedAssembly
        run: |
          dotnet publish /p:TrimMode=full /p:PublishTrimmed=true /p:PublishDir=./../Executable/debugSymbols /p:IntermediateOutputPath=./../Executable/obj/ \
            /p:TrimmerSingleWarn=false /p:SuppressTrimAnalysisWarnings=false /p:IlcGenerateMetadataLog=true /p:IlcGenerateMstatFile=true /p:IlcGenerateDgmlFile=true \
            /p:DisableBufferAutoComposition=false /p:InvariantGlobalization=false /p:IlcDisableReflection=false \
            /p:AssemblyName=AutoComposition.Globalization.Reflection
          mv ./../Executable/debugSymbols/AutoComposition.Globalization.Reflection ./../Executable/AutoComposition.Globalization.Reflection
          dotnet publish /p:TrimMode=full /p:PublishTrimmed=true /p:PublishDir=./../Executable/debugSymbols /p:IntermediateOutputPath=./../Executable/obj/ \
            /p:TrimmerSingleWarn=false /p:SuppressTrimAnalysisWarnings=false /p:IlcGenerateMetadataLog=true /p:IlcGenerateMstatFile=true /p:IlcGenerateDgmlFile=true \
            /p:DisableBufferAutoComposition=true /p:InvariantGlobalization=false /p:IlcDisableReflection=false \
            /p:AssemblyName=Globalization.Reflection
          mv ./../Executable/debugSymbols/Globalization.Reflection ./../Executable/Globalization.Reflection
          dotnet publish /p:TrimMode=full /p:PublishTrimmed=true /p:PublishDir=./../Executable/debugSymbols /p:IntermediateOutputPath=./../Executable/obj/ \
            /p:TrimmerSingleWarn=false /p:SuppressTrimAnalysisWarnings=false /p:IlcGenerateMetadataLog=true /p:IlcGenerateMstatFile=true /p:IlcGenerateDgmlFile=true \
            /p:DisableBufferAutoComposition=false /p:InvariantGlobalization=true /p:IlcDisableReflection=false \
            /p:AssemblyName=AutoComposition.Reflection
          mv ./../Executable/debugSymbols/AutoComposition.Reflection ./../Executable/AutoComposition.Reflection
          dotnet publish /p:TrimMode=full /p:PublishTrimmed=true /p:PublishDir=./../Executable/debugSymbols /p:IntermediateOutputPath=./../Executable/obj/ \
            /p:TrimmerSingleWarn=false /p:SuppressTrimAnalysisWarnings=false /p:IlcGenerateMetadataLog=true /p:IlcGenerateMstatFile=true /p:IlcGenerateDgmlFile=true \
            /p:DisableBufferAutoComposition=false /p:InvariantGlobalization=false /p:IlcDisableReflection=true \
            /p:AssemblyName=AutoComposition.Globalization
          mv ./../Executable/debugSymbols/AutoComposition.Globalization ./../Executable/AutoComposition.Globalization
          dotnet publish /p:TrimMode=full /p:PublishTrimmed=true /p:PublishDir=./../Executable/debugSymbols /p:IntermediateOutputPath=./../Executable/obj/ \
            /p:TrimmerSingleWarn=false /p:SuppressTrimAnalysisWarnings=false /p:IlcGenerateMetadataLog=true /p:IlcGenerateMstatFile=true /p:IlcGenerateDgmlFile=true \
            /p:DisableBufferAutoComposition=true /p:InvariantGlobalization=true /p:IlcDisableReflection=false \
            /p:AssemblyName=Reflection
          mv ./../Executable/debugSymbols/Reflection ./../Executable/Reflection
          dotnet publish /p:TrimMode=full /p:PublishTrimmed=true /p:PublishDir=./../Executable/debugSymbols /p:IntermediateOutputPath=./../Executable/obj/ \
            /p:TrimmerSingleWarn=false /p:SuppressTrimAnalysisWarnings=false /p:IlcGenerateMetadataLog=true /p:IlcGenerateMstatFile=true /p:IlcGenerateDgmlFile=true \
            /p:DisableBufferAutoComposition=true /p:InvariantGlobalization=false /p:IlcDisableReflection=true \
            /p:AssemblyName=Globalization
          mv ./../Executable/debugSymbols/Globalization ./../Executable/Globalization
          dotnet publish /p:TrimMode=full /p:PublishTrimmed=true /p:PublishDir=./../Executable/debugSymbols /p:IntermediateOutputPath=./../Executable/obj/ \
            /p:TrimmerSingleWarn=false /p:SuppressTrimAnalysisWarnings=false /p:IlcGenerateMetadataLog=true /p:IlcGenerateMstatFile=true /p:IlcGenerateDgmlFile=true \
            /p:DisableBufferAutoComposition=false /p:InvariantGlobalization=true /p:IlcDisableReflection=true \
            /p:AssemblyName=AutoComposition
          mv ./../Executable/debugSymbols/AutoComposition ./../Executable/AutoComposition
          dotnet publish /p:TrimMode=full /p:PublishTrimmed=true /p:PublishDir=./../Executable/debugSymbols /p:IntermediateOutputPath=./../Executable/obj/ \
            /p:TrimmerSingleWarn=false /p:SuppressTrimAnalysisWarnings=false /p:IlcGenerateMetadataLog=true /p:IlcGenerateMstatFile=true /p:IlcGenerateDgmlFile=true \
            /p:DisableBufferAutoComposition=true /p:InvariantGlobalization=true /p:IlcDisableReflection=true \
            /p:AssemblyName=None
          mv ./../Executable/debugSymbols/None ./../Executable/None
          
          mv ./../Executable/obj/native ./../Executable/ilcLogs
          rm ./../Executable/ilcLogs/*.o
          rm ./../Executable/ilcLogs/*.ilc.rsp
          rm ./../Executable/ilcLogs/*.exports
          rm -rf ./../Executable/obj
          rm -rf ./../Executable/debugSymbols
          rm -rf ./bin
          rm -rf ./obj
      - name: Run Package-Trimmed-Executables
        working-directory: ./tmpProject/Executable
        run: |
          echo '----- AutoComposition + Globalization + Reflection -----'
          ./AutoComposition.Globalization.Reflection
          echo '----- Globalization + Reflection -----'
          ./Globalization.Reflection
          echo '----- AutoComposition + Reflection -----'
          ./AutoComposition.Reflection
          echo '----- AutoComposition + Globalization -----'
          ./AutoComposition.Globalization
          echo '----- Reflection -----'
          ./Reflection
          echo '----- Globalization -----'
          ./Globalization
          echo '----- AutoComposition -----'
          ./AutoComposition
          echo '----- None -----'
          ./None
      - name: Upload Package-Trimmed-Executables-Logs
        uses: actions/upload-artifact@v4
        with:
          name: Package-Trimmed-Executables-Logs
          path: ./tmpProject/Executable/ilcLogs
  run-tests:
    needs: [ build ]
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ windows-latest, ubuntu-latest, macos-latest, macos-13 ]
    steps:
      - uses: actions/checkout@v4
      - name: Setup .NET
        if: runner.os != 'Windows'
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 9.0.x
      - name: Install WinGet
        if: runner.os == 'Windows'
        uses: Cyberboss/install-winget@v1
      - name: Setup .NET x86
        if: runner.os == 'Windows'
        run: |
          winget install Microsoft.DotNet.SDK.9 --architecture x86 --silent --disable-interactivity --accept-source-agreements
      - name: Setup .NET x64
        if: runner.os == 'Windows'
        run: |
          winget install Microsoft.DotNet.SDK.9 --architecture x64 --silent --force --disable-interactivity --accept-source-agreements
      - name: Build tests
        run: |
          dotnet restore src 
          dotnet build src --configuration Release 
      - name: Windows x86 tests
        if: runner.os == 'Windows'
        run: |
          dotnet test src --no-build --no-restore --configuration Release  --logger "console;verbosity=detailed" --settings src\Test\x86.runsettings
      - name: Run tests
        run: |
          dotnet test src --no-build --no-restore --configuration Release  --logger "console;verbosity=detailed"