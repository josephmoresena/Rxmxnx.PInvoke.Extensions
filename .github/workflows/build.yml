name: Build
on:
  push:
    branches:
      - main
  pull_request:
    types: [ opened, synchronize, reopened ]
jobs:
  build:
    name: Build and analyze
    runs-on: ubuntu-latest
    env:
      MONO_FRAMEWORK_PATH: /usr/lib/mono
    steps:
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: 21
          distribution: 'zulu'
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: |
            3.0.x
            3.1.x
            5.0.x
            6.0.x
            7.0.x
            8.0.x
            9.0.x
      - name: Setup Tree pre-requisites
        run: sudo apt-get install tree unzip --assume-yes
      - name: Setup latest Mono Framework
        run: |
          sudo apt install ca-certificates gnupg --assume-yes
          sudo gpg --homedir /tmp --no-default-keyring --keyring /usr/share/keyrings/mono-official-archive-keyring.gpg --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 3FA7E0328081BFF6A14DA29AA6A19B38D3D831EF
          echo "deb [signed-by=/usr/share/keyrings/mono-official-archive-keyring.gpg] https://download.mono-project.com/repo/ubuntu stable-focal main" | sudo tee /etc/apt/sources.list.d/mono-official-stable.list
          sudo apt update
          
          wget https://archive.ubuntu.com/ubuntu/pool/main/o/openssl/libssl1.1_1.1.0g-2ubuntu4_amd64.deb
          sudo dpkg -i libssl1.1_1.1.0g-2ubuntu4_amd64.deb
          
          sudo apt install mono-complete mono-vbnc mono-dbg gdb libssl3
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Shallow clones should be disabled for a better relevancy of analysis
      - name: Cache SonarCloud packages
        uses: actions/cache@v4
        with:
          path: ~/sonar/cache
          key: ${{ runner.os }}-sonar
          restore-keys: ${{ runner.os }}-sonar
      - name: Cache SonarCloud scanner
        id: cache-sonar-scanner
        uses: actions/cache@v4
        with:
          path: ./.sonar/scanner
          key: ${{ runner.os }}-sonar-scanner
          restore-keys: ${{ runner.os }}-sonar-scanner
      - name: Install SonarCloud scanner
        if: steps.cache-sonar-scanner.outputs.cache-hit != 'true'
        shell: pwsh
        run: |
          New-Item -Path ./.sonar/scanner -ItemType Directory
          dotnet tool update dotnet-sonarscanner --tool-path ./.sonar/scanner 
      - name: Build and analyze Sonar
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # Needed to get PR information, if any
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        shell: pwsh
        run: |
          ./.sonar/scanner/dotnet-sonarscanner begin /k:"josephmoresena_PInvoke.Extensions" /o:"josephmoresena" /d:sonar.token="${{ secrets.SONAR_TOKEN }}" /d:sonar.host.url="https://sonarcloud.io" /d:sonar.scanner.scanAll=false /d:sonar.coverage.exclusions="**Test.cs,**Tests.cs,**test.cs,**tests.cs,**.SourceGenerator/*.cs" /d:sonar.cs.vstest.reportsPaths=TestResults/*.trx /d:sonar.cs.opencover.reportsPaths=TestResults/*/coverage.opencover.xml /d:sonar.cpd.exclusions="**/NativeUtilities/**FixedAction.cs,**/NativeUtilities/**FixedFunc.cs,**/IManagedBinaryBuffer/StaticCompose.cs,**Test/**Tests**/**.cs,**/Localization/**MessageResource.cs"
          dotnet restore src 
          dotnet build src /p:MultipleFrameworkTest=true --configuration Release 
          dotnet test src /p:MultipleFrameworkTest=true --verbosity normal --collect:"XPlat Code Coverage" --results-directory TestResults/  --logger "trx;verbosity=detailed" --no-build --no-restore --configuration Release -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Format=opencover 
          ./.sonar/scanner/dotnet-sonarscanner end /d:sonar.token="${{ secrets.SONAR_TOKEN }}"
      - name: Mono framework tests
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # Needed to get PR information, if any
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        shell: pwsh
        run: |
          mono src/Test/Rxmxnx.PInvoke.Common.Tests/bin/Release/netstandard2.1/nunitlite-runner.exe Rxmxnx.PInvoke.Common.Tests.dll -labels=All --result=TestResults/Rxmxnx.PInvoke.Common.Mono.TestResult..xml
          mono src/Test/Rxmxnx.PInvoke.CString.Tests/bin/Release/netstandard2.1/nunitlite-runner.exe Rxmxnx.PInvoke.CString.Tests.dll -labels=All --result=TestResults/Rxmxnx.PInvoke.CString.Mono.TestResult.xml
          mono src/Test/Rxmxnx.PInvoke.Extensions.Tests/bin/Release/netstandard2.1/nunitlite-runner.exe Rxmxnx.PInvoke.Extensions.Tests.dll -labels=All --result=TestResults/Rxmxnx.PInvoke.Extensions.Mono.TestResult.xml
          mono src/Test/Rxmxnx.PInvoke.Buffers.Tests/bin/Release/netstandard2.1/nunitlite-runner.exe Rxmxnx.PInvoke.Buffers.Tests.dll -labels=All --result=TestResults/Rxmxnx.PInvoke.Buffers.Mono.TestResult.xml
      - name: Pack assembly
        working-directory: ./package/Rxmxnx.PInvoke.Extensions
        run: |
          dotnet pack -c Release /p:Version=9999.99.99.99-tmp /p:NoIntermediateBuild=true
          for package in bin/Release/Rxmxnx.PInvoke.Extensions*.*nupkg; do
            echo "-----------------------------------"
            TEMP_DIR=$(mktemp -d)
            unzip -q "$package" -d "$TEMP_DIR"
            ls -sh "$package"
            tree "$TEMP_DIR" -h --noreport | tail -n +2 | sed "s|$TEMP_DIR/||"
            rm -rf "$TEMP_DIR"
          done
          echo "-----------------------------------"
      - name: Create tmpProject
        run: mkdir tmpProject
      - name: Create PackageTrimmedAssembly.csproj
        working-directory: ./tmpProject
        run: |
          echo '<Project>' > Directory.Build.props
          echo '  <PropertyGroup>' >> Directory.Build.props
          echo '    <JsonSerializerIsReflectionEnabledByDefault>true</JsonSerializerIsReflectionEnabledByDefault>' >> Directory.Build.props
          echo '    <LangVersion>latest</LangVersion>' >> Directory.Build.props
          echo '    <TrimMode>full</TrimMode>' >> Directory.Build.props
          echo '    <PublishTrimmed>true</PublishTrimmed>' >> Directory.Build.props
          echo '    <IsFreeBsdHost>$([MSBuild]::IsOSPlatform('"'"'FreeBSD'"'"'))</IsFreeBsdHost>' >> Directory.Build.props
          echo '    <PublishAot Condition="'"'"'$(IsFreeBsdHost)'"'"' != '"'"'true'"'"'">true</PublishAot>' >> Directory.Build.props
          echo '    <DefineConstants>$(DefineConstants);NATIVE_AOT</DefineConstants>'  >> Directory.Build.props
          echo '    <DefineConstants Condition="'"'"'$(IlcDisableReflection)'"'"' == '"'"'true'"'"'">$(DefineConstants);REFLECTION_FREE</DefineConstants>' >> Directory.Build.props
          echo '  </PropertyGroup>' >> Directory.Build.props
          echo '  <ItemGroup>' >> Directory.Build.props
          echo '    <RuntimeHostConfigurationOption Condition="'"'"'$(DisableBufferAutoComposition)'"'"' == '"'"'true'"'"'" Include="PInvoke.DisableBufferAutoComposition" Value="true" Trim="true" />' >> Directory.Build.props
          echo '  </ItemGroup>' >> Directory.Build.props
          echo '  <ItemGroup Condition="'"'"'$(TargetFramework)'"'"' == '"'"'net45'"'"'">' >> Directory.Build.props
          echo '    <Reference Include="mscorlib">' >> Directory.Build.props
          echo '      <HintPath>$(MONO_FRAMEWORK_PATH)\\4.5\\mscorlib.dll</HintPath>' >> Directory.Build.props
          echo '      <Private>False</Private>' >> Directory.Build.props
          echo '    </Reference>' >> Directory.Build.props
          echo '    <Reference Include="netstandard">' >> Directory.Build.props
          echo '      <HintPath>$(MONO_FRAMEWORK_PATH)\\4.5\\Facades\\netstandard.dll</HintPath>' >> Directory.Build.props
          echo '      </Reference>' >> Directory.Build.props
          echo '  </ItemGroup>' >> Directory.Build.props
          echo '  <ItemGroup Condition="'"'"'$(TargetFramework)'"'"' == '"'"'net45'"'"'">' >> Directory.Build.props
          echo '     <PackageReference Include="System.Collections.Immutable" Version="5.0.0"/>' >> Directory.Build.props
          echo '     <PackageReference Include="System.Runtime.CompilerServices.Unsafe" Version="5.0.0"/>' >> Directory.Build.props
          echo '  </ItemGroup>' >> Directory.Build.props
          echo '</Project>' >> Directory.Build.props  
          dotnet new console --name PackageTrimmedAssembly
      - name: Create PackageTrimmedAssembly NuGet.config
        working-directory: ./tmpProject/PackageTrimmedAssembly
        run: |
          dotnet new nugetconfig
          dotnet nuget add source ../../package/Rxmxnx.PInvoke.Extensions/bin/Release/ -n TmpSource
          dotnet add package Rxmxnx.PInvoke.Extensions --version 9999.99.99.99-tmp
      - name: Create PackageTrimmedAssembly Program.cs
        working-directory: ./tmpProject/PackageTrimmedAssembly
        run: |
          echo '#if !NETCOREAPP
          using System;
          using System.Linq;
          #else
          using System.Text.Json;
          #endif
          using System.Reflection;
          using System.Buffers;
          using System.Globalization;
          using System.Runtime.CompilerServices;
          using System.Runtime.InteropServices;
          using System.Text;
          
          using Rxmxnx.PInvoke.Buffers;
          #if NET8_0_OR_GREATER
          using System.Text.Json.Serialization;
          #endif
          
          #if NET5_0_OR_GREATER
          using System.Diagnostics.CodeAnalysis;
          #endif
          
          namespace Rxmxnx.PInvoke.ApplicationTest
          {
          #if NET5_0_OR_GREATER
          	[UnconditionalSuppressMessage("Trimming", "IL2026", Justification = "This is AOT Safe")]
          	[UnconditionalSuppressMessage("Trimming", "IL2091", Justification = "This is AOT Safe")]
          	[UnconditionalSuppressMessage("SingleFile", "IL3000", Justification = "Ignore")]
          	[UnconditionalSuppressMessage("AOT", "IL3050", Justification = "This is AOT Safe")]
          #endif
          #if !NET8_0_OR_GREATER
          	internal static class Program
          #else
          	internal static partial class Program
          #endif
          	{
          		public static void Main()
          		{
          			RuntimeHelper.PrintRuntimeInfo();
                    #if NETCOREAPP
                    if (!AotInfo.IsNativeAot) {
          				new TrimmedByNativeAot(Console.Out)
                          .WriteUtf8("This text will be removed when compiled using NativeAOT."u8);
                    }
                    #endif
          
          			Double[,] mxm = { { 0.3, -2.2, 3.2, 0, }, { 0.12, -2, 0.2, 6, }, { 9, 0, 0, -1, }, { 2, 2.1, -1, 4, }, };
          			Double[,] nxn = { { 2, 3, }, { 2, 1, }, };
          			Double[,] mxn = { { -1, 1, }, { 4, 0, }, { 2, 1, }, { 1, 3, }, };
          
          			Console.WriteLine("=== 4x4 ===");
          			Program.Print(mxm);
          			Console.WriteLine($"Determinant 4x4: {Program.GetDeterminant(mxm, out Double[,] inverse):0.####}");
          			Console.WriteLine("=== (4x4)^-1 ===");
          			Program.Print(inverse);
                    Console.WriteLine("=== (4x4)^-1 (Text) -> [] ===");
                    Program.ToText(inverse).AsSpan().WithSafeFixed(Program.Print);
          			Console.WriteLine("=== 2x2 ===");
          			Program.Print(nxn);
          			Console.WriteLine($"Determinant 2x2: {Program.GetDeterminant(nxn):0.####}");
          			Console.WriteLine("=== 4x2 ===");
          			Program.Print(mxn);
          			Console.WriteLine("=== 4x4 * 4x2 ===");
          			Program.Print(Program.Multiply(mxm, mxn));
          			Console.WriteLine("=== 2x2 -> [] ===");
          			mxn.AsSpan().WithSafeFixed(Program.Print);
                    Console.WriteLine("=== 2x2 (Text) -> [] ===");
                    Program.ToText(mxn).AsSpan().WithSafeFixed(Program.Print);
          			Console.WriteLine("=== Stack allocations ===");
          			Action registerMetadataObject =
          				Program
          					.GetRegister<Composite<Atomic<Object>, Composite<Atomic<Object>, Atomic<Object>, Object>,
          						Object>>();
          			Action registerMetadataValue = Program
          				.GetRegister<
          					Composite<Atomic<ValueTuple<Int32, String>>,
          						Composite<Atomic<ValueTuple<Int32, String>>, Atomic<ValueTuple<Int32, String>>,
          							ValueTuple<Int32, String>>, ValueTuple<Int32, String>>, ValueTuple<Int32, String>>();
          			Action registerMetadataNullableValue = Program
          				.GetNullableRegister<
          					Composite<Atomic<ValueTuple<Int32, String>?>,
          						Composite<Atomic<ValueTuple<Int32, String>?>, Atomic<ValueTuple<Int32, String>?>,
          							ValueTuple<Int32, String>?>, ValueTuple<Int32, String>?>, ValueTuple<Int32, String>>();
          
          			Console.WriteLine("=== Stack alloc [Int32] ===");
          			BufferManager.Alloc<Int32>(3, Program.Generate);
          			BufferManager.Alloc<Int32>(5, Program.Generate);
          			Console.WriteLine("=== Stack alloc [Double?] ===");
          			BufferManager.Alloc<Double?>(3, Program.Generate);
          			BufferManager.Alloc<Double?>(5, Program.Generate);
          			Console.WriteLine("=== Stack alloc [String] ===");
          			BufferManager.Alloc<String?>(3, Program.Generate);
          			if (!BufferManager.BufferAutoCompositionEnabled)
          			{
          				registerMetadataObject();
          				BufferManager.Alloc<String?>(3, Program.Generate);
          			}
          			BufferManager.Alloc<String?>(5, Program.Generate);
          			Console.WriteLine("=== Stack alloc [(Int32, String)] ===");
          			BufferManager.Alloc<ValueTuple<Int32, String>>(3, Program.Generate);
          			if (!BufferManager.BufferAutoCompositionEnabled)
          			{
          				registerMetadataValue();
          				BufferManager.Alloc<ValueTuple<Int32, String>>(3, Program.Generate);
          			}
          			BufferManager.Alloc<ValueTuple<Int32, String>>(5, Program.Generate);
          			Console.WriteLine("=== Stack alloc [(Int32, String)?] ===");
          			BufferManager.Alloc<ValueTuple<Int32, String>?>(3, Program.Generate);
          			if (!BufferManager.BufferAutoCompositionEnabled)
          			{
          				registerMetadataNullableValue();
          				BufferManager.Alloc<ValueTuple<Int32, String>?>(3, Program.Generate);
          			}
          			BufferManager.Alloc<ValueTuple<Int32, String>?>(5, Program.Generate);
          
          #if NETCOREAPP
          			Console.WriteLine("=== System.Text.Json ===");
          #else
          			Console.WriteLine("=== UTF-8 / UTF-16 Convert ===");
          #endif
          			CStringSequence sequence = new CStringSequence("String0", "String1", null, "String3", "", "String5");
          			try
          			{
          				SerializableMessage<String> serializable = ConvertHelper.Convert(new SerializableMessage<CString>
          				{
          					Title = (CString)"This is not a message",
          					Message = (CString)"This is a UTF-8 message for you.",
          				});
          				Console.WriteLine(ConvertHelper.Convert(serializable));
          				String initialBuffer = sequence.ToString();
          				sequence = ConvertHelper.Convert(ConvertHelper.Convert(sequence));
          				Console.WriteLine(
          					$"Buffer Equality: {initialBuffer == sequence.ToString()}\tBuffer Instance: {Object.ReferenceEquals(initialBuffer, sequence.ToString())}");
          			}
          			catch (Exception ex)
          			{
          				Console.WriteLine($"**Unable to perform conversion: {ex.Message}**");
          			}
          			Console.WriteLine("=== Enumerable sequences ===");
          			foreach (CString value in sequence)
          				Console.WriteLine(!value.IsZero ? value : RuntimeHelper.Null);
          			foreach (Byte utf8U in RuntimeHelper.Null)
          				Console.Write((Char)utf8U);
          			Console.WriteLine("");
          			ArrayWrapper<Int32> values = new ArrayWrapper<Int32> { Value = new Int32[] { 1, 2, 3, -1, -2, -3, }, };
          			foreach (Int32 val in values)
          				Console.WriteLine(val);
          			if (sequence.Count > 0)
          				Console.WriteLine("=== UTF-8 Enumerable ===");
          			foreach (ReadOnlySpan<Byte> utf8 in sequence.CreateView())
          				Console.WriteLine($"Address: 0x{utf8.GetUnsafeIntPtr().ToString("X")}\t" +
          				                  $"Length: {utf8.Length}\t" +
          				                  $"Bytes: {Convert.ToBase64String(utf8)}\t" +
          				                  $"Text: {Encoding.UTF8.GetString(utf8)}");
          			Console.WriteLine("=== Referenceable Wrapper ===");
          			IMutableReference<Guid> uuid = IMutableReference.Create(Guid.NewGuid());
          
          			Program.Print(uuid);
          			uuid.Reference = Guid.NewGuid();
          			Program.Print(uuid);
          
          			Console.WriteLine("=== Fixed Rent ===");
          			using IFixedContext<Int64>.IDisposable fRent =
          				ArrayPool<Int64>.Shared.RentFixed(10, false, out Int32 arrayLength);
          			Console.WriteLine(
          				$"Address: 0x{fRent.Pointer.ToString("X")}\tRequired: {fRent.Values.Length}\tRented: {arrayLength}");
          			foreach (ref Int64 rLong in fRent.Values)
          				rLong = RuntimeHelper.Shared.Next();
          			Program.Print(fRent);
          		}
          
          		private static String[,] ToText(Double[,] source)
          		{
          		    String[,] result = new String[source.GetLength(0), source.GetLength(1)];
          		    ReadOnlySpan<Double> sourceSpan = source.AsSpan();
          		    Span<String> resultSpan = result.AsSpan();
          		    for (Int32 i = 0; i < sourceSpan.Length; i++)
          		    	resultSpan[i] = sourceSpan[i].ToString(CultureInfo.InvariantCulture);
          		    return result;
          		}
                private static Double GetDeterminant(Double[,] matrix)
          		{
          			Int32 n;
          			if (matrix.Rank != 2 || (n = matrix.GetLength(0)) != matrix.GetLength(1))
          				throw new InvalidOperationException("Determinant is only for square matrices.");
          			if (n == 0)
          				return 1;
          
          			Double determinant = MatrixHelper.GetDeterminant(matrix.AsSpan(), n);
          			return determinant;
          		}
          		private static Double GetDeterminant(Double[,] matrix, out Double[,] inverse)
          		{
          			Int32 n;
          			if (matrix.Rank != 2 || (n = matrix.GetLength(0)) != matrix.GetLength(1))
          				throw new InvalidOperationException("Determinant is only for square matrices.");
          			if (n == 0)
          			{
          				inverse = MatrixHelper.EmptyMatrix;
          				return 1;
          			}
          
          			Double determinant = MatrixHelper.GetDeterminant(matrix.AsSpan(), n, out inverse);
          			return determinant;
          		}
          		private static Double[,] Multiply(Double[,] matrixA, Double[,] matrixB)
          		{
          			if (matrixA.Rank != 2)
          				throw new InvalidOperationException("Invalid A matrix.");
          			if (matrixB.Rank != 2)
          				throw new InvalidOperationException("Invalid B matrix.");
          
          			Int32 aRow = matrixA.GetLength(0);
          			Int32 bCol = matrixB.GetLength(1);
          			Int32 n;
          			if ((n = matrixA.GetLength(1)) != matrixB.GetLength(0))
          				throw new InvalidOperationException(
          					"The number of columns in A matrix must equal the number of rows in B matrix.");
          
          			if (aRow == 0 || n == 0 || bCol == 0) return MatrixHelper.EmptyMatrix;
          			Double[,] result = new Double[aRow, bCol];
          
          			MatrixHelper.MultiplyMatrices(matrixA.AsSpan(), matrixB.AsSpan(), aRow, bCol, n, result.AsSpan());
          			return result;
          		}
          		private static void Generate(ScopedBuffer<String?> buff)
          		{
          			Program.PrintBufferInfo(buff);
          			for (Int32 i = 0; i < buff.Span.Length; i++)
          				buff.Span[i] = $"Index: {i} Value: {Guid.NewGuid()}";
          
          			Program.Print<String?>(buff.Span);
          			Program.CollectGarbage();
          			Program.Print<String?>(buff.Span);
          		}
          		private static void Generate(ScopedBuffer<Int32> buff)
          		{
          			Program.PrintBufferInfo(buff);
          			for (Int32 i = 0; i < buff.Span.Length; i++)
          				buff.Span[i] = RuntimeHelper.Shared.Next();
          
          			Program.Print<Int32>(buff.Span);
          			Program.CollectGarbage();
          			Program.Print<Int32>(buff.Span);
          		}
          		private static void Generate(ScopedBuffer<Double?> buff)
          		{
          			Program.PrintBufferInfo(buff);
          			for (Int32 i = 0; i < buff.Span.Length; i++)
          				buff.Span[i] = RuntimeHelper.Shared.Next(0, 5) >= 2 ? RuntimeHelper.Shared.NextDouble() : null;
          
          			Program.Print<Double?>(buff.Span);
          			Program.CollectGarbage();
          			Program.Print<Double?>(buff.Span);
          		}
          		private static void Generate(ScopedBuffer<ValueTuple<Int32, String>> buff)
          		{
          			Program.PrintBufferInfo(buff);
          			for (Int32 i = 0; i < buff.Span.Length; i++)
          				buff.Span[i] = (RuntimeHelper.Shared.Next(), $"Index: {i} Value: {Guid.NewGuid()}");
          
          			Program.Print<ValueTuple<Int32, String>>(buff.Span);
          			Program.CollectGarbage();
          			Program.Print<ValueTuple<Int32, String>>(buff.Span);
          		}
          		private static void Generate(ScopedBuffer<ValueTuple<Int32, String>?> buff)
          		{
          			Program.PrintBufferInfo(buff);
          			for (Int32 i = 0; i < buff.Span.Length; i++)
          				buff.Span[i] = RuntimeHelper.Shared.Next(0, 5) >= 2 ?
          					(RuntimeHelper.Shared.Next(), $"Index: {i} Value: {Guid.NewGuid()}") :
          					null;
          
          			Program.Print<ValueTuple<Int32, String>?>(buff.Span);
          			Program.CollectGarbage();
          			Program.Print<ValueTuple<Int32, String>?>(buff.Span);
          		}
          
          		private static void CollectGarbage()
          		{
          			Console.WriteLine("Begin GC.Collect()");
          			GC.Collect();
          			try
          			{
          				GC.WaitForFullGCComplete();
          			}
          			catch (NotImplementedException)
          			{
          				Console.WriteLine("**Unable to call GC.WaitForFullGCComplete()**");
          			}
          			Console.WriteLine("End GC.Collect()");
          		}
          		private static void Print(Double[,] matrix)
          		{
          			if (matrix.Rank != 2)
          				throw new InvalidOperationException("Invalid matrix.");
          			if (matrix.GetLength(0) <= 0 || matrix.GetLength(0) <= 0) return;
          			MatrixHelper.PrintMatrix(matrix.AsSpan(), matrix.GetLength(0), matrix.GetLength(1));
          		}
          		private static void Print<T>(ReadOnlySpan<T> span)
          		{
          			foreach (ref readonly T item in span)
          				Console.WriteLine(item);
          		}
          		private static void Print(IMutableReference<Guid> uuid)
          		{
          			Program.CollectGarbage();
          			ref Guid refU = ref uuid.Reference;
          			Console.WriteLine(
          				$"Address: 0x{refU.AsBytes().GetUnsafeIntPtr().ToString("X")}\tWrapper: {uuid.Value}\tRef: {uuid.Reference}");
          		}
          		private static void Print<T>(in IFixedContext<T> ctx)
          		{
          			Console.Write($"Address: 0x{ctx.Pointer.ToString("X")}\tItems: {ctx.Values.Length} ");
          			foreach (T value in ctx.Values)
          				Console.Write($"{value} ");
          			Console.WriteLine("");
          		}
          		private static void PrintBufferInfo<T>(ScopedBuffer<T> buff)
          		{
          			Console.WriteLine($"Span Size: {buff.Span.Length}\t" + $"Buffer Size: {buff.FullLength}\t" +
          			                  $"In Stack: {buff.InStack}\t" +
          			                  $"Components: {String.Join(", ", buff.BufferMetadata?.Select(c => c.Size) ?? Enumerable.Empty<UInt16>())}");
          		}
          		private static Action GetRegister<TBuffer>() where TBuffer : struct, IManagedBinaryBuffer<Object>
          		{
          			return static () =>
          			{
          				BufferManager.Register<TBuffer>();
          				Console.WriteLine($"{new TBuffer().Metadata.Size} buffer registered.");
          			};
          		}
          		private static Action GetRegister<TBuffer, T>() where TBuffer : struct, IManagedBinaryBuffer<T> where T : struct
          		{
          			return static () =>
          			{
          				BufferManager.Register<T, TBuffer>();
          				Console.WriteLine($"{new TBuffer().Metadata.Size} buffer registered.");
          			};
          		}
          		private static Action GetNullableRegister<TBuffer, T>() where TBuffer : struct, IManagedBinaryBuffer<T?>
          			where T : struct
          		{
          			return static () =>
          			{
          				BufferManager.RegisterNullable<T, TBuffer>();
          				Console.WriteLine($"{new TBuffer().Metadata.Size} buffer registered.");
          			};
          		}
          
          		private static String GetName(this Architecture architecture)
          			=> architecture switch
          			{
          				Architecture.X86 => nameof(Architecture.X86),
          				Architecture.X64 => nameof(Architecture.X64),
          				Architecture.Arm => nameof(Architecture.Arm),
          				Architecture.Arm64 => nameof(Architecture.Arm64),
          #if NET5_0_OR_GREATER
          				Architecture.Wasm => nameof(Architecture.Wasm),
          #endif
          #if NET6_0_OR_GREATER
          				Architecture.S390x => nameof(Architecture.S390x),
          #endif
          #if NET7_0_OR_GREATER
          				Architecture.LoongArch64 => nameof(Architecture.LoongArch64),
          				Architecture.Armv6 => nameof(Architecture.Armv6),
          				Architecture.Ppc64le => nameof(Architecture.Ppc64le),
          #endif
          #if NET9_0_OR_GREATER
          				Architecture.RiscV64 => nameof(Architecture.RiscV64),
          #endif
          				_ => architecture.ToString(),
          			};
          
          		public class SerializableMessage<T>
          			where T : class, IEquatable<String>, IEquatable<T>, IComparable<String>, IComparable<T>
          		{
          			public T? Title { get; set; }
          			public T? Message { get; set; }
          
          			public override String ToString()
          				=> $"{{ Title: {this.Title?.ToString() ?? "null"}, Message: {this.Message?.ToString() ?? ""} }}";
          		}
          
          		private static class ConvertHelper
          		{
          			public static SerializableMessage<String> Convert(SerializableMessage<CString> value)
          #if !NETCOREAPP
                    	=> new SerializableMessage<String>
                    	{
                    		Title = value.Title?.ToString(), Message = value.Message?.ToString(),
                    	};
          #else
          			{
          				String serialized = JsonSerializer.Serialize(value, AppJsonSerializerContext.SerializerOptions);
          				return JsonSerializer.Deserialize<SerializableMessage<String>>(
          					serialized, AppJsonSerializerContext.SerializerOptions)!;
          			}
          #endif
          			public static SerializableMessage<CString> Convert(SerializableMessage<String> value)
          #if !NETCOREAPP
          				=> new SerializableMessage<CString> { Title = (CString?)value.Title, Message =
          					(CString?)value.Message, };
          #else
          			{
          				String serialized = JsonSerializer.Serialize(value, AppJsonSerializerContext.SerializerOptions);
          				return JsonSerializer.Deserialize<SerializableMessage<CString>>(
          					serialized, AppJsonSerializerContext.SerializerOptions)!;
          			}
          #endif
          			public static String?[] Convert(CStringSequence sequence)
          			{
          #if NETCOREAPP
          				String serialized = JsonSerializer.Serialize(sequence, AppJsonSerializerContext.SerializerOptions);
          				return JsonSerializer.Deserialize<String?[]>(serialized, AppJsonSerializerContext.SerializerOptions)!;
          #else
                    		String?[] result = new String?[sequence.Count];
                    		Int32 index = 0;
                    		foreach (ReadOnlySpan<Byte> utf8Text in sequence.CreateView())
                    		{
                    			result[index] = !Unsafe.IsNullRef(ref MemoryMarshal.GetReference(utf8Text)) ?
                    				Encoding.UTF8.GetString(utf8Text) :
                    				default;
                    			index++;
                    		}
                    		return result;
          #endif
          			}
          			public static CStringSequence Convert(params String?[] sequence)
          #if !NETCOREAPP
          				=> new CStringSequence(sequence);
          #else
          			{
          				String serialized = JsonSerializer.Serialize(sequence, AppJsonSerializerContext.SerializerOptions);
          				return JsonSerializer.Deserialize<CStringSequence>(
          					serialized, AppJsonSerializerContext.SerializerOptions)!;
          			}
          #endif
          		}
          
          		private class ArrayWrapper<T> : IEnumerableSequence<T>, IMutableWrapper<T[]>
          		{
          			public T[] Value { get; set; } = Array.Empty<T>();
          
          			public Int32 GetSize() => this.Value.Length;
          			public T GetItem(Int32 index) => this.Value[index];
          		}
          
          		private static class MatrixHelper
          		{
          			private const Double epsilon = 1e-12;
          
          			public static readonly Double[,] EmptyMatrix = new Double[0, 0];
          
          			public static Double GetDeterminant(ReadOnlySpan<Double> matrix, Int32 n)
          			{
          				Double[]? array = default;
          				Span<Double> tempMatrix = n > 4 ?
          					(array = ArrayPool<Double>.Shared.Rent(matrix.Length)).AsSpan()[..matrix.Length] :
          					stackalloc Double[matrix.Length];
          				try
          				{
          					matrix.CopyTo(tempMatrix);
          
          					Double det = 1;
          					Int32 swaps = 0;
          
          					for (Int32 row = 0; row < n; row++)
          					{
          						Double pivot = MatrixHelper.GetPivot(tempMatrix, n, false, row, out Int32 maxRow);
          
          						if (Math.Abs(pivot) < MatrixHelper.epsilon)
          							return 0;
          
          						swaps += MatrixHelper.SwapRow(tempMatrix, n, row, maxRow) ? 1 : 0;
          
          						for (Int32 k = row + 1; k < n; k++)
          						{
          							Double factor = tempMatrix[k * n + row] / tempMatrix[row * n + row];
          							for (Int32 j = row; j < n; j++)
          								tempMatrix[k * n + j] -= factor * tempMatrix[row * n + j];
          						}
          					}
          
          					for (Int32 i = 0; i < n; i++)
          						det *= tempMatrix[i * n + i];
          					if (swaps % 2 != 0) det = -det;
          					return det;
          				}
          				finally
          				{
          					if (array is not null)
          						ArrayPool<Double>.Shared.Return(array);
          				}
          			}
          			public static Double GetDeterminant(ReadOnlySpan<Double> matrix, Int32 n, out Double[,] inverse)
          			{
          				Double[]? array = default;
          				Span<Double> augmented = n > 4 ?
          					(array = ArrayPool<Double>.Shared.Rent(2 * matrix.Length)).AsSpan()[..(2 * matrix.Length)] :
          					stackalloc Double[2 * matrix.Length];
          				try
          				{
          					Double determinant = 1.0;
          					Int32 swaps = 0;
          
          					MatrixHelper.FillAugmented(matrix, n, augmented);
          					for (Int32 row = 0; row < n; row++)
          					{
          						Double pivot = MatrixHelper.GetPivot(augmented, n, true, row, out Int32 maxRow);
          						if (Math.Abs(pivot) < MatrixHelper.epsilon)
          						{
          							inverse = MatrixHelper.EmptyMatrix;
          							return 0;
          						}
          
          						determinant *= pivot;
          						swaps += MatrixHelper.SwapRow(augmented, 2 * n, row, maxRow) ? 1 : 0;
          						MatrixHelper.NormalizeRow(augmented, n, row, pivot);
          						MatrixHelper.RowReduction(augmented, n, row);
          					}
          
          					inverse = new Double[n, n];
          					if (swaps % 2 != 0)
          						determinant = -determinant;
          					MatrixHelper.CopyInverse(augmented, n, inverse.AsSpan());
          					return determinant;
          				}
          				finally
          				{
          					if (array is not null)
          						ArrayPool<Double>.Shared.Return(array);
          				}
          			}
          			public static void MultiplyMatrices(ReadOnlySpan<Double> matrixA, ReadOnlySpan<Double> matrixB, Int32 aRow,
          				Int32 bCol, Int32 n, Span<Double> result)
          			{
          				for (Int32 row = 0; row < aRow; row++)
          				for (Int32 aCol = 0; aCol < bCol; aCol++)
          				{
          					Double sum = 0;
          					for (Int32 col = 0; col < n; col++)
          						sum += matrixA[row * n + col] * matrixB[col * bCol + aCol];
          					result[row * bCol + aCol] = sum;
          				}
          			}
          
          			private static void FillAugmented(ReadOnlySpan<Double> matrix, Int32 n, Span<Double> augmented)
          			{
          				// [A | I]
          				for (Int32 row = 0; row < n; row++)
          				for (Int32 col = 0; col < n; col++)
          					(augmented[row * 2 * n + col], augmented[row * 2 * n + col + n]) =
          						(matrix[row * n + col], row == col ? 1.0 : 0.0);
          			}
          			private static void CopyInverse(Span<Double> augmented, Int32 n, Span<Double> inverseAsSpan)
          			{
          				for (Int32 i = 0; i < n; i++)
          				for (Int32 j = 0; j < n; j++)
          					inverseAsSpan[i * n + j] = augmented[i * 2 * n + j + n];
          			}
          			private static void NormalizeRow(Span<Double> augmented, Int32 n, Int32 row, Double pivot)
          			{
          				for (Int32 col = 0; col < 2 * n; col++)
          					augmented[row * 2 * n + col] /= pivot;
          			}
          			private static void RowReduction(Span<Double> augmented, Int32 n, Int32 normalizedRow)
          			{
          				for (Int32 row = 0; row < n; row++)
          				{
          					if (row == normalizedRow) continue;
          					Double factor = augmented[row * 2 * n + normalizedRow];
          					for (Int32 col = 0; col < 2 * n; col++)
          						augmented[row * 2 * n + col] -= factor * augmented[normalizedRow * 2 * n + col];
          				}
          			}
          			private static Double GetPivot(ReadOnlySpan<Double> matrix, Int32 n, Boolean isAugmented, Int32 currentRow,
          				out Int32 maxRow)
          			{
          				maxRow = currentRow;
          
          				Int32 multiplier = isAugmented ? 2 : 1;
          				for (Int32 row = currentRow + 1; row < n; row++)
          					if (Math.Abs(matrix[row * multiplier * n + currentRow]) >
          					    Math.Abs(matrix[maxRow * multiplier * n + currentRow]))
          						maxRow = row;
          				return matrix[maxRow * multiplier * n + currentRow];
          			}
          			public static void PrintMatrix(ReadOnlySpan<Double> matrix, Int32 nRow, Int32 nCol)
          			{
          				Int32 addCol = (matrix.Length - nRow * nCol) / nRow;
          				StringBuilder? strBuild = addCol > 0 ? new StringBuilder() : default;
          				for (Int32 row = 0; row < nRow; row++)
          				{
          					strBuild?.Append("\t|\t");
          					for (Int32 col = 0; col < nCol; col++)
          					{
          						Console.Write($"{matrix[row * (nCol + addCol) + col]:0.####}\t");
          						if (strBuild is null || col >= addCol) continue;
          						strBuild.Append($"{matrix[row * (nCol + addCol) + col + nRow]:0.####}\t");
          					}
          					Console.WriteLine(strBuild?.ToString());
          					strBuild?.Clear();
          				}
          			}
          			private static Boolean SwapRow(Span<Double> matrix, Int32 nCol, Int32 row1, Int32 row2)
          			{
          				if (row1 == row2) return false;
          				for (Int32 col = 0; col < nCol; col++)
          					(matrix[row1 * nCol + col], matrix[row2 * nCol + col]) = (matrix[row2 * nCol + col],
          						matrix[row1 * nCol + col]);
          				return true;
          			}
          		}
          
          		private static class RuntimeHelper
          		{
          			private const String literalName =
          #if !NETCOREAPP
          					"Read-only byte span"
          #else
          					"UTF-8 literal"
          #endif
          				;
          			private static ReadOnlySpan<Byte> GetLiteralNull()
          #if !NETCOREAPP
                    		=> (new Byte[] { 110, 117, 108, 108, 0, }).AsSpan()[..^1];
          #else
          				=> "null"u8;
          #endif
          
          			public static readonly CString Null = new(RuntimeHelper.GetLiteralNull);
          			public static readonly Random Shared = new Random();
          
          			public static void PrintRuntimeInfo()
          			{
          				const String runtimeName =
          #if NET9_0_OR_GREATER
          						".NET 9.0"
          #elif NET8_0_OR_GREATER
          						".NET 8.0"
          #elif NET7_0_OR_GREATER
          						".NET 7.0"
          #elif NET6_0_OR_GREATER
          						".NET 6.0"
          #elif NET5_0_OR_GREATER
          						".NET 5.0"
          #elif NETCOREAPP3_1
          						".NET Core 3.1"
          #elif NETCOREAPP3_0
          						".NET Core 3.0"
          #else
          						"Mono"
          #endif
          #if REFLECTION_FREE
          						+ " Reflection-free"
          #endif
          #if NATIVE_AOT
          						+ " NativeAOT"
          #endif
          					;
          				Console.WriteLine("========== Application for " + runtimeName + " ==========");
          				RuntimeHelper.PrintDomainInfo();
          				Console.WriteLine("========== Runtime information ==========");
          				Console.WriteLine($"Number of Cores: {Environment.ProcessorCount}");
          				Console.WriteLine($"Is Little-Endian: {BitConverter.IsLittleEndian}");
          				Console.WriteLine($"OS: {RuntimeInformation.OSDescription}");
          				Console.WriteLine($"OS Arch: {RuntimeInformation.OSArchitecture.GetName()}");
          				Console.WriteLine($"OS Version: {Environment.OSVersion}");
          				Console.WriteLine($"Computer: {Environment.MachineName}");
          				Console.WriteLine($"User: {Environment.UserName}");
          				Console.WriteLine($"UI Culture: {CultureInfo.CurrentUICulture.TwoLetterISOLanguageName}");
          				Console.WriteLine($"System Path: {Environment.SystemDirectory}");
          				Console.WriteLine($"Current Path: {Environment.CurrentDirectory}");
          				Console.WriteLine($"Process Arch: {RuntimeInformation.ProcessArchitecture.GetName()}");
          				try
          				{
          					Console.WriteLine($"Framework Version: {Environment.Version}");
          					Console.WriteLine($"Runtime Path: {RuntimeEnvironment.GetRuntimeDirectory()}");
          					Console.WriteLine($"Runtime Version: {RuntimeEnvironment.GetSystemVersion()}");
          				}
          				catch (Exception)
          				{
          					Console.WriteLine("**Unable to retrieve runtime info**");
          				}
          				Console.WriteLine("========== Rxmxnx.PInvoke Runtime information ==========");
          				Console.WriteLine($"Native AOT: {AotInfo.IsNativeAot}");
          				Console.WriteLine($"Reflection Enabled: {!AotInfo.IsReflectionDisabled}");
          				Console.WriteLine($"Pointer Size: {NativeUtilities.PointerSize}");
          				Console.WriteLine($"Globalization-Invariant Mode: {NativeUtilities.GlobalizationInvariantModeEnabled}");
          				Console.WriteLine($"UI Iso639-1: {NativeUtilities.UserInterfaceIso639P1}");
          				Console.WriteLine($"Buffer AutoComposition Enabled: {BufferManager.BufferAutoCompositionEnabled}");
          				Console.WriteLine($"{RuntimeHelper.literalName}: {!RuntimeHelper.GetLiteralNull().MayBeNonLiteral()}");
          				Console.WriteLine($"String constant: {!RuntimeHelper.literalName.AsSpan().MayBeNonLiteral()}");
                        Console.WriteLine($"CString.Empty literal: {!MemoryMarshal.CreateReadOnlySpan(ref Unsafe.AsRef(in CString.Empty.GetPinnableReference()), 1).MayBeNonLiteral()}");
          			}
          			private static void PrintDomainInfo()
          			{
          				try
          				{
          					ReadOnlySpan<Assembly> span = AppDomain.CurrentDomain.GetAssemblies();
          					foreach (Assembly assembly in span)
          					{
          						if (assembly == Assembly.GetExecutingAssembly()) continue;
          						Console.WriteLine(assembly.FullName +
          						                  (!AotInfo.IsNativeAot ? $" {assembly.Location}" : String.Empty));
          					}
          				}
          				catch (Exception)
          				{
          					Console.WriteLine("**Unable to retrieve domain info**");
          				}
          			}
          		}
          
          #if NETCOREAPP
          #if NET8_0_OR_GREATER
          		[JsonSerializable(typeof(String))]
          		[JsonSerializable(typeof(CString))]
          		[JsonSerializable(typeof(CStringSequence))]
          		[JsonSerializable(typeof(String[]))]
          		[JsonSerializable(typeof(SerializableMessage<CString>))]
          		[JsonSerializable(typeof(SerializableMessage<String>))]
          		public partial class AppJsonSerializerContext : JsonSerializerContext
          #else
          		public static class AppJsonSerializerContext
          #endif
          		{
          			public static JsonSerializerOptions SerializerOptions
          #if NET8_0_OR_GREATER
          				=> AppJsonSerializerContext.Default.Options;
          #else
          			{
          				get;
          			} = new JsonSerializerOptions()
          			{
          				Converters = { new CString.JsonConverter(), new CStringSequence.JsonConverter(), },
          			};
          #endif
          		}
          		public sealed class TrimmedByNativeAot(TextWriter writer) 
          		{
          			public void WriteUtf8(ReadOnlySpan<Byte> utf8) {
                        writer.WriteLine("==== Native AOT Trim ====");
                    	writer.WriteLine(new CString(utf8));
          			}
          		}
          #endif
          	}
          }' > Program.cs
      - name: Build Package-Trimmed-Executables (PackageTrimmedAssembly)
        working-directory: ./tmpProject/PackageTrimmedAssembly
        run: |
          dotnet publish /p:TrimMode=full /p:PublishTrimmed=true /p:PublishDir=./../Executable/debugSymbols /p:IntermediateOutputPath=./../Executable/obj/ \
            /p:TrimmerSingleWarn=false /p:SuppressTrimAnalysisWarnings=false /p:IlcGenerateMetadataLog=true /p:IlcGenerateMstatFile=true /p:IlcGenerateDgmlFile=true \
            /p:DisableBufferAutoComposition=false /p:InvariantGlobalization=false /p:IlcDisableReflection=false \
            /p:AssemblyName=AutoComposition.Globalization.Reflection
          mv ./../Executable/debugSymbols/AutoComposition.Globalization.Reflection ./../Executable/AutoComposition.Globalization.Reflection
          dotnet publish /p:TrimMode=full /p:PublishTrimmed=true /p:PublishDir=./../Executable/debugSymbols /p:IntermediateOutputPath=./../Executable/obj/ \
            /p:TrimmerSingleWarn=false /p:SuppressTrimAnalysisWarnings=false /p:IlcGenerateMetadataLog=true /p:IlcGenerateMstatFile=true /p:IlcGenerateDgmlFile=true \
            /p:DisableBufferAutoComposition=true /p:InvariantGlobalization=false /p:IlcDisableReflection=false \
            /p:AssemblyName=Globalization.Reflection
          mv ./../Executable/debugSymbols/Globalization.Reflection ./../Executable/Globalization.Reflection
          dotnet publish /p:TrimMode=full /p:PublishTrimmed=true /p:PublishDir=./../Executable/debugSymbols /p:IntermediateOutputPath=./../Executable/obj/ \
            /p:TrimmerSingleWarn=false /p:SuppressTrimAnalysisWarnings=false /p:IlcGenerateMetadataLog=true /p:IlcGenerateMstatFile=true /p:IlcGenerateDgmlFile=true \
            /p:DisableBufferAutoComposition=false /p:InvariantGlobalization=true /p:IlcDisableReflection=false \
            /p:AssemblyName=AutoComposition.Reflection
          mv ./../Executable/debugSymbols/AutoComposition.Reflection ./../Executable/AutoComposition.Reflection
          dotnet publish /p:TrimMode=full /p:PublishTrimmed=true /p:PublishDir=./../Executable/debugSymbols /p:IntermediateOutputPath=./../Executable/obj/ \
            /p:TrimmerSingleWarn=false /p:SuppressTrimAnalysisWarnings=false /p:IlcGenerateMetadataLog=true /p:IlcGenerateMstatFile=true /p:IlcGenerateDgmlFile=true \
            /p:DisableBufferAutoComposition=false /p:InvariantGlobalization=false /p:IlcDisableReflection=true \
            /p:AssemblyName=AutoComposition.Globalization
          mv ./../Executable/debugSymbols/AutoComposition.Globalization ./../Executable/AutoComposition.Globalization
          dotnet publish /p:TrimMode=full /p:PublishTrimmed=true /p:PublishDir=./../Executable/debugSymbols /p:IntermediateOutputPath=./../Executable/obj/ \
            /p:TrimmerSingleWarn=false /p:SuppressTrimAnalysisWarnings=false /p:IlcGenerateMetadataLog=true /p:IlcGenerateMstatFile=true /p:IlcGenerateDgmlFile=true \
            /p:DisableBufferAutoComposition=true /p:InvariantGlobalization=true /p:IlcDisableReflection=false \
            /p:AssemblyName=Reflection
          mv ./../Executable/debugSymbols/Reflection ./../Executable/Reflection
          dotnet publish /p:TrimMode=full /p:PublishTrimmed=true /p:PublishDir=./../Executable/debugSymbols /p:IntermediateOutputPath=./../Executable/obj/ \
            /p:TrimmerSingleWarn=false /p:SuppressTrimAnalysisWarnings=false /p:IlcGenerateMetadataLog=true /p:IlcGenerateMstatFile=true /p:IlcGenerateDgmlFile=true \
            /p:DisableBufferAutoComposition=true /p:InvariantGlobalization=false /p:IlcDisableReflection=true \
            /p:AssemblyName=Globalization
          mv ./../Executable/debugSymbols/Globalization ./../Executable/Globalization
          dotnet publish /p:TrimMode=full /p:PublishTrimmed=true /p:PublishDir=./../Executable/debugSymbols /p:IntermediateOutputPath=./../Executable/obj/ \
            /p:TrimmerSingleWarn=false /p:SuppressTrimAnalysisWarnings=false /p:IlcGenerateMetadataLog=true /p:IlcGenerateMstatFile=true /p:IlcGenerateDgmlFile=true \
            /p:DisableBufferAutoComposition=false /p:InvariantGlobalization=true /p:IlcDisableReflection=true \
            /p:AssemblyName=AutoComposition
          mv ./../Executable/debugSymbols/AutoComposition ./../Executable/AutoComposition
          dotnet publish /p:TrimMode=full /p:PublishTrimmed=true /p:PublishDir=./../Executable/debugSymbols /p:IntermediateOutputPath=./../Executable/obj/ \
            /p:TrimmerSingleWarn=false /p:SuppressTrimAnalysisWarnings=false /p:IlcGenerateMetadataLog=true /p:IlcGenerateMstatFile=true /p:IlcGenerateDgmlFile=true \
            /p:DisableBufferAutoComposition=true /p:InvariantGlobalization=true /p:IlcDisableReflection=true \
            /p:AssemblyName=None
          mv ./../Executable/debugSymbols/None ./../Executable/None
          
          mv ./../Executable/obj/native ./../Executable/ilcLogs
          rm ./../Executable/ilcLogs/*.o
          rm ./../Executable/ilcLogs/*.ilc.rsp
          rm ./../Executable/ilcLogs/*.exports
          rm -rf ./../Executable/obj
          rm -rf ./../Executable/debugSymbols
          rm -rf ./bin
          rm -rf ./obj
      - name: Run Package-Trimmed-Executables
        continue-on-error: true
        working-directory: ./tmpProject/Executable
        run: |
          echo '----- AutoComposition + Globalization + Reflection -----'
          ./AutoComposition.Globalization.Reflection
          echo '----- Globalization + Reflection -----'
          ./Globalization.Reflection
          echo '----- AutoComposition + Reflection -----'
          ./AutoComposition.Reflection
          echo '----- AutoComposition + Globalization -----'
          ./AutoComposition.Globalization
          echo '----- Reflection -----'
          ./Reflection
          echo '----- Globalization -----'
          ./Globalization
          echo '----- AutoComposition -----'
          ./AutoComposition
          echo '----- None -----'
          ./None
      - name: Mono-Run
        working-directory: ./tmpProject/PackageTrimmedAssembly
        run: |
          msbuild -restore /p:TargetFramework=net45 /p:Configuration=Release /p:ImplicitUsings=disable > ./../Executable/ilcLogs/PackageTrimmedAssembly.exe.Mono.Build.log 2>&1
          mono -O=all bin/Release/net45/PackageTrimmedAssembly.exe
      - name: Mono-AOT Run
        continue-on-error: true
        working-directory: ./tmpProject/PackageTrimmedAssembly
        run: |
          MONO_LOG_LEVEL=debug mono --aot=full,hybrid -O=all bin/Release/net45/netstandard.dll > ./../Executable/ilcLogs/netstandard.dll.Mono.AOT.log 2>&1
          MONO_LOG_LEVEL=debug mono --aot=full,hybrid -O=all bin/Release/net45/System.Runtime.CompilerServices.Unsafe.dll > ./../Executable/ilcLogs/System.Runtime.CompilerServices.Unsafe.Mono.AOT.log 2>&1
          MONO_LOG_LEVEL=debug mono --aot=full,hybrid -O=all bin/Release/net45/System.Collections.Immutable.dll > ./../Executable/ilcLogs/System.Collections.Immutable.Mono.AOT.log 2>&1
          MONO_LOG_LEVEL=debug mono --aot=full,hybrid -O=all bin/Release/net45/Rxmxnx.PInvoke.Extensions.dll > ./../Executable/ilcLogs/Rxmxnx.PInvoke.Extensions.dll.Mono.AOT.log 2>&1
          MONO_LOG_LEVEL=debug mono --aot=full,hybrid -O=all bin/Release/net45/PackageTrimmedAssembly.exe > ./../Executable/ilcLogs/PackageTrimmedAssembly.exe.Mono.AOT.log 2>&1
          MONO_LOG_LEVEL=debug mono -O=all bin/Release/net45/PackageTrimmedAssembly.exe > ./../Executable/ilcLogs/PackageTrimmedAssembly.exe.Mono.AOT.Run.log 2>&1
      - name: Upload Package-Trimmed-Executables-Logs
        uses: actions/upload-artifact@v4
        with:
          name: Package-Trimmed-Executables-Logs
          path: ./tmpProject/Executable/ilcLogs
      - name: Clean workspace
        id: clean-workspace
        run: |
          rm -rf .git
          rm -rf .sonarqube
          rm -rf TestResults
          rm -rf ./../_temp
          rm -rf ./tmpProject/Executable
          dotnet clean src 
      - name: Test in FreeBSD
        uses: vmactions/freebsd-vm@v1
        with:
          release: "13.5"
          usesh: true
          copyback: false
          prepare: |
            pkg install -y python39 sqlite3 unixODBC libgdiplus zip ca_root_nss dotnet
            /usr/local/bin/python3.9 -m ensurepip
            /usr/local/bin/python3.9 -m pip install pillow
            
            mkdir -p ~/fake-py39-pillow/metadata
            cat > ~/fake-py39-pillow/metadata/+COMPACT_MANIFEST <<EOF
            name: py39-pillow
            version: 9.9.9
            origin: fake/py39-pillow
            comment: Fake package to satisfy dependency on py39-pillow
            desc: This is a fake py39-pillow package to satisfy dependencies.
            categories: [python]
            maintainer: a@b.c
            www: https://py-pillow.org
            prefix: /usr/local
            licenselogic: single
            licenses: [MIT]
            flatsize: 0
            EOF
            pkg register -M ~/fake-py39-pillow/metadata/+COMPACT_MANIFEST
            
            fetch https://github.com/Thefrank/freebsd-port-sooners/releases/download/20230712/mono6.12-6.12.0.199_1.pkg
            pkg add mono6.12-6.12.0.199_1.pkg
          run: |
            cd ./tmpProject/PackageTrimmedAssembly
            mono ./bin/Release/net45/PackageTrimmedAssembly.exe 
            dotnet run
  run-tests:
    needs: [ build ]
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ windows-2025, ubuntu-latest, macos-latest ]
    steps:
      - uses: actions/checkout@v4
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        if: runner.os != 'Windows'
        with:
          dotnet-version: |
            6.0.x
            7.0.x
            8.0.x
            9.0.x
      - name: Setup .NET x86
        if: runner.os == 'Windows'
        run: |
          winget install Microsoft.DotNet.SDK.6  --architecture x86 --silent --force --disable-interactivity --accept-source-agreements 
          winget install Microsoft.DotNet.SDK.7 --architecture x86 --silent --force --disable-interactivity --accept-source-agreements 
          winget install Microsoft.DotNet.SDK.8 --architecture x86 --silent --force --disable-interactivity --accept-source-agreements  
          winget install Microsoft.DotNet.SDK.9 --architecture x86 --silent --force --disable-interactivity --accept-source-agreements 
      - name: Setup .NET x64
        if: runner.os == 'Windows'
        run: |
          winget install Microsoft.DotNet.SDK.6 --architecture x64 --silent --force --disable-interactivity --accept-source-agreements
          winget install Microsoft.DotNet.SDK.7 --architecture x64 --silent --force --disable-interactivity --accept-source-agreements
          winget install Microsoft.DotNet.SDK.8 --architecture x64 --silent --force --disable-interactivity --accept-source-agreements
          winget install Microsoft.DotNet.SDK.9 --architecture x64 --silent --force --disable-interactivity --accept-source-agreements
      - name: Build tests
        run: |
          dotnet restore src 
          dotnet build src /p:MultipleFrameworkTest=true /p:OnlySupportedFrameworkTest=true --configuration Release
      - name: Windows x86 tests
        if: runner.os == 'Windows'
        run: |
          dotnet test src /p:MultipleFrameworkTest=true /p:OnlySupportedFrameworkTest=true --no-build --no-restore --configuration Release  --logger "console;verbosity=detailed" --settings src\Test\x86.runsettings
      - name: Run tests
        run: |
          dotnet test src /p:MultipleFrameworkTest=true /p:OnlySupportedFrameworkTest=true --no-build --no-restore --configuration Release  --logger "console;verbosity=detailed"